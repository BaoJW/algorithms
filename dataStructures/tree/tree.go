package tree

// 二叉树
/***
       1
      / \
     2   3
    /   / \
   4   5   6
       /     \
      7       8
***/
// 1. 每个节点下方直接相连的节点称为子节点，上方直接相连的节点称为父节点
// 2. 我们称最上方那个没有父节点的节点1为根节点，称最下层没有子节点的节点4、7、8为叶子节点
// 3. 我们称从根节点到最下方叶子节点经过的节点个数为二叉树的最大深度/高度,上面这棵树的最大深度是4，即从根节点1到叶子节点7或8的路径上的节点个数

// 满二叉树（Perfect Binary Tree）
/***
            1
          /   \
         2     3
        / \   / \
       4   5 6   7
      / \ / \ / \ / \
     8  9 A B C D E F

***/
// 1. 满二叉树就是每一层节点都是满的，整棵树像一个正三角形
// 2. 满二叉树有个优势，就是他的节点个数很好算，假设深度为h,那么总节点数就是2^h-1,即等比数列求和
// 3. 满二叉树就是一种特殊的完全二叉树

// 完全二叉树（Complete Binary Tree）
/***
            1
          /   \
         2     3
        / \   / \
       4   5 6   7
      / \ / \
     8  9 A  B

***/
// 1. 完全二叉树是指，二叉树的每一层的节点都紧靠左排列，且除了最后一层，其他每层都必须是满的
// 2. 由于他的节点紧凑排列，如果从左到右从上到下对他的每个节点编号，那么父子节点的索引存在明显的规律(待后续补充)

// 二叉搜索树(Binary Search Tree, 简称BST)
/***
        5
       / \
      3   7
     / \   \
    2   4   8
***/
// 1. 定义：对于树中的每个节点，其左子树的每个节点的值都要小于这个节点的值，右子树的每个节点的值都要大于这个节点的值 【左小右大】
// 2. BST是非常常用的数据结构，因为左小右大的特性，可以让我们在BST中快速找到某个节点，或者找到某个范围内的所有节点，这是BST的优势所在
// 比方说，对于一棵普通的二叉树，其中的节点大小没有任何规律可言，那么你要找到某个值为x的节点，只能从根节点开始遍历整棵树，
// 而对于BST，你可以先对比根节点和x的大小关系，如果x比根节点大，那么根节点的整棵左子树就可以直接排除了，直接从右子树开始找，这样就可以快速定位到值为x的那个节点
// 3. BST的中序遍历结果是有序的
